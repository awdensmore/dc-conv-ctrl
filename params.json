{"name":"Dc-conv-ctrl","tagline":"Control a Dc/DC converter using STM32.","body":"### Purpose ###\r\nThe aim of the project is to characterize the behavior of VRLA batteries so that online estimates of state of charge (SoC) and state of health (SoH) can be made using simple measurements: voltage, current, temperature and impedance. To do so, this repo is a hardware/software project to implement an aging process during which the data is collected. After collection, it is processed using a machine learning technique to build a data-driven model of the battery behavior.\r\n\r\nThis project is the work of the Power Electronics Research Group at the [University of Cape Town](http://www.ee.uct.ac.za)\r\n\r\n### Features ###\r\n\r\n* Implemented using an STM32F0 ARM MCU\r\n* Independently control the charging and discharging of up to 5 VRLA batteries\r\n* Inject a small ripple voltage during charging or discharging (Electrochemical Impedance Spectroscopy, used to determine the impedance)\r\n* Reverse polarity protection on the power terminals (not on the batteries)\r\n* Control features implemented on the STM32, efficiency measurements with ATMEGA2560 (using Arduino libraries).\r\n\r\n### Functions ###\r\nA smaller-grain look at what's needed to build the high-level features:\r\n* Modulate PWM signal to generate ripple voltage\r\n    * DC converter is bidirectional with 2 FETs. During charging top fet controls buck converter, bottom fet is off. During discharge, bottom fet controls output, top fet is off.\r\n* CC/CV charging control\r\n    * Constant current until ~14V (what is full charge)?\r\n    * Constant voltage until current reaches 0.01C\r\n    * Rest (1hr?)\r\n* Programmable electronic load:\r\n    * PWM controlled FET with heat sink\r\n    * CC discharge until 10.5V\r\n* Current measurement:\r\n    * Charging / discharging: measured at the specialized sensor to get I @ battery side of DC converter\r\n    * Power / load side: measured at the opposite side of converter to get efficiency\r\n* Voltage measurement: taken at the specialized sensor to get V @ battery side of DC converter\r\n\r\n### Pin Requirements ###\r\n**STM32 (Converter Control)**\r\n\r\n|Function|Pin Type|Quantity|\r\n---------|--------|---------\r\n| Ibat | ADC     | 5       |\r\n| Vbat | ADC     | 5       |\r\n| PWM (charging)| PWM | 10 |\r\n| PWM (discharging)| PWM | 5 |\r\n| Discharge light| GPIO | 5 |\r\n\r\n**ATMEGA2560 (DC/DC Eff. Data)**\r\n\r\n|Function|Pin Type|Quantity|\r\n---------|--------|---------\r\n| Ic | ADC     | 5       |\r\n| Vc | ADC | 5 |\r\n\r\n**TI F2833** (Data collection)\r\n\r\n|Function|Pin Type|Quantity|\r\n---------|--------|---------\r\n| Ibat | ADC     | 5       |\r\n| Vbat | ADC     | 5       |\r\n| Veis | ADC     | 5       |\r\n| Tbat | ADC | 5 |\r\n\r\n### Project Notes\r\nThis is a general list of notes of important tips I've learned along the way.\r\n\r\n**PWM using DMA** - This is useful to rapidly change the PWM duty cycle without accessing the CPU. Some important tips when using CubeMX to generate the setup code:\r\n\r\n```C\r\n    hdma_tim1_ch1.Instance = DMA1_Channel2;\r\n    hdma_tim1_ch1.Init.Direction = DMA_MEMORY_TO_PERIPH;\r\n    hdma_tim1_ch1.Init.PeriphInc = DMA_PINC_DISABLE;\r\n    hdma_tim1_ch1.Init.MemInc = DMA_MINC_ENABLE;\r\n    hdma_tim1_ch1.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;\r\n    hdma_tim1_ch1.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;\r\n    hdma_tim1_ch1.Init.Mode = DMA_CIRCULAR;\r\n    hdma_tim1_ch1.Init.Priority = DMA_PRIORITY_HIGH;\r\n    HAL_DMA_Init(&hdma_tim1_ch1);\r\n```\r\n\r\nI couldn't get this to work until I set MemInc to enable and alignment to word (defaulted to byte). To start the PWM use:\r\n\r\n```C\r\n    uint32_t duty_cycle[i] = {x, y, ..., i};  // Value from 0-2^16. Must be less than period\r\n    HAL_TIM_PWM_Start_DMA(&htim1, TIM_CHANNEL_1, duty_cycle, i);\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}